"""
Vulnerability Scanner

Checks dependencies for known security vulnerabilities.
"""

import json
from dataclasses import dataclass, field
from typing import List, Dict, Optional
from enum import Enum
from pathlib import Path

from .dependency_analyzer import DependencyAnalysis, Ecosystem


class Severity(Enum):
    """Vulnerability severity levels."""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


@dataclass
class Vulnerability:
    """Represents a security vulnerability."""
    id: str  # CVE or advisory ID
    package_name: str
    affected_version: str
    severity: Severity
    title: str
    description: str
    cve_id: Optional[str] = None
    cvss_score: Optional[float] = None
    fixed_in: Optional[str] = None
    references: List[str] = field(default_factory=list)
    published_date: Optional[str] = None


@dataclass
class VulnerabilityScanResult:
    """Results of vulnerability scanning."""
    project_path: str
    total_vulnerabilities: int
    critical: int
    high: int
    medium: int
    low: int
    info: int
    vulnerabilities: List[Vulnerability] = field(default_factory=list)
    scanned_packages: int = 0
    errors: List[str] = field(default_factory=list)


class VulnerabilityScanner:
    """Scans dependencies for known vulnerabilities."""

    def __init__(self):
        # In production, this would query actual vulnerability databases
        # like OSV (Open Source Vulnerabilities), GitHub Advisory, etc.
        self.vulnerability_db = self._load_mock_vulnerability_db()

    def scan_dependencies(
        self,
        analysis: DependencyAnalysis,
        include_low: bool = True
    ) -> VulnerabilityScanResult:
        """
        Scan dependencies for vulnerabilities.

        Args:
            analysis: DependencyAnalysis from analyzer
            include_low: Include low severity vulnerabilities

        Returns:
            VulnerabilityScanResult with findings
        """
        vulnerabilities = []
        errors = []

        for dep in analysis.dependencies:
            try:
                vulns = self._check_package_vulnerabilities(
                    dep.name,
                    dep.version,
                    dep.ecosystem
                )

                if not include_low:
                    vulns = [v for v in vulns if v.severity != Severity.LOW]

                vulnerabilities.extend(vulns)

            except Exception as e:
                errors.append(f"Error checking {dep.name}: {e}")

        # Count by severity
        severity_counts = {
            'critical': sum(1 for v in vulnerabilities if v.severity == Severity.CRITICAL),
            'high': sum(1 for v in vulnerabilities if v.severity == Severity.HIGH),
            'medium': sum(1 for v in vulnerabilities if v.severity == Severity.MEDIUM),
            'low': sum(1 for v in vulnerabilities if v.severity == Severity.LOW),
            'info': sum(1 for v in vulnerabilities if v.severity == Severity.INFO),
        }

        return VulnerabilityScanResult(
            project_path=analysis.project_path,
            total_vulnerabilities=len(vulnerabilities),
            critical=severity_counts['critical'],
            high=severity_counts['high'],
            medium=severity_counts['medium'],
            low=severity_counts['low'],
            info=severity_counts['info'],
            vulnerabilities=vulnerabilities,
            scanned_packages=len(analysis.dependencies),
            errors=errors
        )

    def _check_package_vulnerabilities(
        self,
        package_name: str,
        version: str,
        ecosystem: Ecosystem
    ) -> List[Vulnerability]:
        """Check a single package for vulnerabilities."""
        vulnerabilities = []

        # Look up in database
        ecosystem_key = ecosystem.value
        if ecosystem_key in self.vulnerability_db:
            if package_name in self.vulnerability_db[ecosystem_key]:
                vuln_data = self.vulnerability_db[ecosystem_key][package_name]

                # Check if version is affected
                for vuln in vuln_data:
                    if self._is_version_affected(version, vuln.get('affected_versions', [])):
                        vulnerabilities.append(Vulnerability(
                            id=vuln['id'],
                            package_name=package_name,
                            affected_version=version,
                            severity=Severity(vuln['severity']),
                            title=vuln['title'],
                            description=vuln['description'],
                            cve_id=vuln.get('cve_id'),
                            cvss_score=vuln.get('cvss_score'),
                            fixed_in=vuln.get('fixed_in'),
                            references=vuln.get('references', []),
                            published_date=vuln.get('published_date')
                        ))

        return vulnerabilities

    def _is_version_affected(self, version: str, affected_ranges: List[str]) -> bool:
        """Check if a version is affected by vulnerability."""
        if not affected_ranges:
            return False

        # Normalize version
        version = version.lstrip('v').strip()

        # Simple version matching (in production, use proper semver comparison)
        for range_str in affected_ranges:
            if '<' in range_str:
                # e.g., "<2.0.0"
                max_version = range_str.replace('<', '').strip()
                if self._compare_versions(version, max_version) < 0:
                    return True
            elif range_str == version:
                return True
            elif '*' in range_str:
                # e.g., "1.2.*"
                pattern = range_str.replace('*', '')
                if version.startswith(pattern):
                    return True

        return False

    def _compare_versions(self, v1: str, v2: str) -> int:
        """
        Compare two versions.
        Returns: -1 if v1 < v2, 0 if equal, 1 if v1 > v2
        """
        try:
            parts1 = [int(p) for p in v1.split('.') if p.isdigit()]
            parts2 = [int(p) for p in v2.split('.') if p.isdigit()]

            # Pad shorter version with zeros
            max_len = max(len(parts1), len(parts2))
            parts1 += [0] * (max_len - len(parts1))
            parts2 += [0] * (max_len - len(parts2))

            for p1, p2 in zip(parts1, parts2):
                if p1 < p2:
                    return -1
                elif p1 > p2:
                    return 1

            return 0
        except:
            return 0  # Can't compare

    def _load_mock_vulnerability_db(self) -> Dict:
        """
        Load mock vulnerability database for demonstration.

        In production, this would:
        - Query OSV API: https://osv.dev/
        - Query GitHub Advisory Database
        - Query National Vulnerability Database
        - Cache results locally
        """
        return {
            'python': {
                'django': [
                    {
                        'id': 'GHSA-xxxx-yyyy-zzzz',
                        'cve_id': 'CVE-2023-12345',
                        'severity': 'high',
                        'title': 'SQL Injection in Django ORM',
                        'description': 'Django versions before 3.2.18 are vulnerable to SQL injection through the ORM when using raw queries.',
                        'affected_versions': ['<3.2.18', '<4.0.10'],
                        'fixed_in': '3.2.18, 4.0.10',
                        'cvss_score': 8.1,
                        'references': [
                            'https://www.djangoproject.com/weblog/2023/feb/14/security-releases/',
                            'https://nvd.nist.gov/vuln/detail/CVE-2023-12345'
                        ],
                        'published_date': '2023-02-14'
                    }
                ],
                'requests': [
                    {
                        'id': 'GHSA-abcd-efgh-ijkl',
                        'cve_id': 'CVE-2023-32681',
                        'severity': 'medium',
                        'title': 'Unintended leak of Proxy-Authorization header',
                        'description': 'Requests library may leak Proxy-Authorization headers to destination servers.',
                        'affected_versions': ['<2.31.0'],
                        'fixed_in': '2.31.0',
                        'cvss_score': 6.1,
                        'references': [
                            'https://github.com/psf/requests/security/advisories/GHSA-abcd-efgh-ijkl'
                        ],
                        'published_date': '2023-05-22'
                    }
                ],
                'flask': [
                    {
                        'id': 'PYSEC-2023-0001',
                        'cve_id': 'CVE-2023-30861',
                        'severity': 'high',
                        'title': 'Flask session fixation vulnerability',
                        'description': 'Flask versions before 2.3.2 are vulnerable to session fixation attacks.',
                        'affected_versions': ['<2.3.2'],
                        'fixed_in': '2.3.2',
                        'cvss_score': 7.5,
                        'references': [
                            'https://github.com/pallets/flask/security/advisories/GHSA-m2qf-hxjv-5gpq'
                        ],
                        'published_date': '2023-05-02'
                    }
                ],
                'pillow': [
                    {
                        'id': 'PYSEC-2023-0002',
                        'cve_id': 'CVE-2023-44271',
                        'severity': 'critical',
                        'title': 'Arbitrary code execution via crafted image',
                        'description': 'Pillow library allows arbitrary code execution when processing specially crafted images.',
                        'affected_versions': ['<10.0.1'],
                        'fixed_in': '10.0.1',
                        'cvss_score': 9.8,
                        'references': [
                            'https://github.com/python-pillow/Pillow/security/advisories'
                        ],
                        'published_date': '2023-10-03'
                    }
                ]
            },
            'npm': {
                'express': [
                    {
                        'id': 'GHSA-1234-5678-9abc',
                        'cve_id': 'CVE-2024-12345',
                        'severity': 'medium',
                        'title': 'Open Redirect in Express.js',
                        'description': 'Express.js versions before 4.18.0 are vulnerable to open redirect attacks.',
                        'affected_versions': ['<4.18.0'],
                        'fixed_in': '4.18.0',
                        'cvss_score': 6.1,
                        'references': [
                            'https://github.com/expressjs/express/security/advisories'
                        ],
                        'published_date': '2024-01-15'
                    }
                ],
                'lodash': [
                    {
                        'id': 'GHSA-5555-6666-7777',
                        'cve_id': 'CVE-2021-23337',
                        'severity': 'high',
                        'title': 'Prototype Pollution in lodash',
                        'description': 'Command injection vulnerability in lodash.',
                        'affected_versions': ['<4.17.21'],
                        'fixed_in': '4.17.21',
                        'cvss_score': 7.2,
                        'references': [
                            'https://github.com/lodash/lodash/security/advisories'
                        ],
                        'published_date': '2021-02-15'
                    }
                ],
                'axios': [
                    {
                        'id': 'GHSA-8888-9999-aaaa',
                        'cve_id': 'CVE-2023-45857',
                        'severity': 'medium',
                        'title': 'SSRF in axios',
                        'description': 'Server-Side Request Forgery (SSRF) vulnerability in axios.',
                        'affected_versions': ['<1.6.0'],
                        'fixed_in': '1.6.0',
                        'cvss_score': 5.9,
                        'references': [
                            'https://github.com/axios/axios/security/advisories'
                        ],
                        'published_date': '2023-11-08'
                    }
                ]
            }
        }


def check_vulnerabilities(
    project_path: str,
    ecosystem: Optional[str] = None,
    include_low: bool = True
) -> Dict:
    """
    Convenience function to check vulnerabilities.

    Args:
        project_path: Path to project directory
        ecosystem: Specific ecosystem to check
        include_low: Include low severity vulnerabilities

    Returns:
        Dictionary with vulnerability scan results
    """
    from .dependency_analyzer import DependencyAnalyzer

    # First analyze dependencies
    analyzer = DependencyAnalyzer()
    analysis = analyzer.analyze_project(project_path, ecosystem)

    # Then scan for vulnerabilities
    scanner = VulnerabilityScanner()
    result = scanner.scan_dependencies(analysis, include_low)

    return {
        'project_path': result.project_path,
        'total_vulnerabilities': result.total_vulnerabilities,
        'critical': result.critical,
        'high': result.high,
        'medium': result.medium,
        'low': result.low,
        'info': result.info,
        'scanned_packages': result.scanned_packages,
        'vulnerabilities': [
            {
                'id': vuln.id,
                'package_name': vuln.package_name,
                'affected_version': vuln.affected_version,
                'severity': vuln.severity.value,
                'title': vuln.title,
                'description': vuln.description,
                'cve_id': vuln.cve_id,
                'cvss_score': vuln.cvss_score,
                'fixed_in': vuln.fixed_in,
                'references': vuln.references,
                'published_date': vuln.published_date
            }
            for vuln in result.vulnerabilities
        ],
        'errors': result.errors
    }
