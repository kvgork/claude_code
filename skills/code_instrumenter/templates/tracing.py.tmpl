"""
OpenTelemetry Instrumentation
Auto-generated by code-instrumenter skill

Service: {{ service_name }}
Jaeger Endpoint: {{ jaeger_endpoint }}
Sampling Rate: {{ sampling_rate }}
"""
from opentelemetry import trace
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor
from opentelemetry.exporter.jaeger.thrift import JaegerExporter
{% if auto_instrument_fastapi %}
from opentelemetry.instrumentation.fastapi import FastAPIInstrumentor
{% endif %}
{% if auto_instrument_sqlalchemy %}
from opentelemetry.instrumentation.sqlalchemy import SQLAlchemyInstrumentor
{% endif %}
{% if auto_instrument_redis %}
from opentelemetry.instrumentation.redis import RedisInstrumentor
{% endif %}
{% if auto_instrument_http %}
from opentelemetry.instrumentation.requests import RequestsInstrumentor
{% endif %}
from opentelemetry.sdk.resources import Resource
from opentelemetry.sdk.trace.sampling import ParentBasedTraceIdRatio
import logging

logger = logging.getLogger(__name__)


def setup_tracing(app=None, service_name: str = "{{ service_name }}"):
    """
    Set up OpenTelemetry distributed tracing.

    Args:
        app: Application instance (FastAPI, Flask, etc.)
        service_name: Name of the service for tracing

    Returns:
        TracerProvider instance
    """
    try:
        # Create resource with service name
        resource = Resource.create({
            "service.name": service_name,
            "service.version": "{{ service_version | default('1.0.0') }}",
            "deployment.environment": "{{ environment | default('development') }}"
        })

        # Create tracer provider with sampling
        sampler = ParentBasedTraceIdRatio({{ sampling_rate }})
        provider = TracerProvider(
            resource=resource,
            sampler=sampler
        )
        trace.set_tracer_provider(provider)

        # Configure Jaeger exporter
        jaeger_exporter = JaegerExporter(
            agent_host_name="{{ jaeger_host | default('localhost') }}",
            agent_port={{ jaeger_port | default(6831) }},
        )

        # Add span processor for async export
        span_processor = BatchSpanProcessor(
            jaeger_exporter,
            max_queue_size=2048,
            schedule_delay_millis=5000,
            export_timeout_millis=30000,
        )
        provider.add_span_processor(span_processor)

        logger.info(f"OpenTelemetry tracing initialized for service: {service_name}")
        logger.info(f"Jaeger endpoint: {{ jaeger_endpoint }}")
        logger.info(f"Sampling rate: {{ sampling_rate * 100 }}%")

{% if auto_instrument_fastapi %}
        # Auto-instrument FastAPI
        if app is not None:
            FastAPIInstrumentor.instrument_app(app)
            logger.info("FastAPI auto-instrumentation enabled")
{% endif %}

{% if auto_instrument_sqlalchemy %}
        # Auto-instrument SQLAlchemy
        SQLAlchemyInstrumentor().instrument()
        logger.info("SQLAlchemy auto-instrumentation enabled")
{% endif %}

{% if auto_instrument_redis %}
        # Auto-instrument Redis
        RedisInstrumentor().instrument()
        logger.info("Redis auto-instrumentation enabled")
{% endif %}

{% if auto_instrument_http %}
        # Auto-instrument HTTP requests
        RequestsInstrumentor().instrument()
        logger.info("HTTP requests auto-instrumentation enabled")
{% endif %}

        return provider

    except Exception as e:
        logger.error(f"Failed to initialize tracing: {e}")
        raise


def get_tracer(name: str = __name__):
    """
    Get a tracer instance for manual instrumentation.

    Args:
        name: Tracer name (usually __name__)

    Returns:
        Tracer instance
    """
    return trace.get_tracer(name)


# Decorator for manual span creation
def trace_span(span_name: str):
    """
    Decorator to create a span around a function.

    Usage:
        @trace_span("process_payment")
        def process_payment(amount):
            # Function code
            pass
    """
    def decorator(func):
        from functools import wraps

        @wraps(func)
        async def async_wrapper(*args, **kwargs):
            tracer = get_tracer()
            with tracer.start_as_current_span(span_name) as span:
                # Add function arguments as span attributes
                span.set_attribute("function.name", func.__name__)
                if args:
                    span.set_attribute("function.args_count", len(args))
                if kwargs:
                    span.set_attribute("function.kwargs_count", len(kwargs))

                try:
                    result = await func(*args, **kwargs)
                    span.set_attribute("function.success", True)
                    return result
                except Exception as e:
                    span.set_attribute("function.success", False)
                    span.set_attribute("function.error", str(e))
                    span.record_exception(e)
                    raise

        @wraps(func)
        def sync_wrapper(*args, **kwargs):
            tracer = get_tracer()
            with tracer.start_as_current_span(span_name) as span:
                # Add function arguments as span attributes
                span.set_attribute("function.name", func.__name__)
                if args:
                    span.set_attribute("function.args_count", len(args))
                if kwargs:
                    span.set_attribute("function.kwargs_count", len(kwargs))

                try:
                    result = func(*args, **kwargs)
                    span.set_attribute("function.success", True)
                    return result
                except Exception as e:
                    span.set_attribute("function.success", False)
                    span.set_attribute("function.error", str(e))
                    span.record_exception(e)
                    raise

        # Return appropriate wrapper based on function type
        import asyncio
        if asyncio.iscoroutinefunction(func):
            return async_wrapper
        else:
            return sync_wrapper

    return decorator


# Export public API
__all__ = [
    "setup_tracing",
    "get_tracer",
    "trace_span"
]
